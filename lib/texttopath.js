// Generated by CoffeeScript 1.3.3
(function() {
  var TextToPath,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  TextToPath = (function() {

    function TextToPath($, fabric, canvas, properties) {
      this.$ = $;
      this.fabric = fabric;
      this.canvas = canvas;
      if (properties == null) {
        properties = "";
      }
      this._setText = __bind(this._setText, this);

      this._mergeProperties(properties);
      this._setText();
    }

    TextToPath.prototype.defaultProperties = {
      fontSize: 50,
      letterSpacing: 0,
      fill: "#000000",
      stroke: "none",
      strokeWidth: 0,
      text: void 0,
      fontFamily: void 0,
      fontData: void 0,
      angle: 0,
      top: 0,
      left: 0
    };

    TextToPath.prototype._setText = function() {
      if (this.fabricGroup) {
        this.canvas.remove(this.fabricGroup);
      }
      this._splitString();
      this._createTextObject();
      this._buildFabricEles();
      return this.canvas.renderAll();
    };

    TextToPath.prototype._splitString = function() {
      var char, index, _i, _len, _ref;
      this.splitText = [];
      _ref = this.customProperties.text.split('');
      for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
        char = _ref[index];
        this.splitText.push(char);
      }
      return this.splitText;
    };

    TextToPath.prototype._buildMeta = function() {
      return this.textObj.meta = {
        fontFamily: this.$(this.customProperties.fontData).find("font-face").attr("font-family"),
        unitsPerEm: parseInt(this.$(this.customProperties.fontData).find("font-face").attr("units-per-em"), 10),
        defaultCharWidth: parseInt(this.$(this.customProperties.fontData).find("font").attr("horiz-adv-x"), 10),
        ascent: parseInt(this.$(this.customProperties.fontData).find("font-face").attr("ascent"), 10)
      };
    };

    TextToPath.prototype._buildGlyphs = function() {
      var _this = this;
      this.textObj.glyphs = [];
      return this.splitText.forEach(function(item, i) {
        var glyphEquiv;
        glyphEquiv = _this.$(_this.customProperties.fontData).find("[unicode='" + item + "']");
        if (glyphEquiv.length === 0) {
          glyphEquiv = _this.$(_this.customProperties.fontData).find("missing-glyph");
        }
        return _this.textObj.glyphs.push({
          name: glyphEquiv.attr("glyph-name"),
          unicode: glyphEquiv.attr("unicode"),
          path: glyphEquiv.attr("d"),
          width: _this._findCharWidth(glyphEquiv)
        });
      });
    };

    TextToPath.prototype._findCharWidth = function(glyphEquiv) {
      if (glyphEquiv.attr("horiz-adv-x") === void 0) {
        return this.textObj.meta.defaultCharWidth;
      } else {
        return parseInt(glyphEquiv.attr("horiz-adv-x"), 10);
      }
    };

    TextToPath.prototype._calculateKerning = function() {
      var index, kernEle, obj, _i, _len, _ref, _results;
      _ref = this.textObj.glyphs;
      _results = [];
      for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
        obj = _ref[index];
        if (index !== this.textObj.glyphs.length - 1) {
          kernEle = this.$("hkern[u1='" + obj.unicode + "']").filter("[u2='" + this.textObj.glyphs[index + 1].unicode + "']");
          if (this.customProperties.letterSpacing > 0 || this.customProperties.letterSpacing < 0) {
            obj.width = obj.width + this._calcScale(this.customProperties.letterSpacing);
          }
          if (kernEle.length > 0) {
            _results.push(obj.width = obj.width - parseInt(kernEle.attr('k'), 10));
          } else {
            _results.push(void 0);
          }
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    TextToPath.prototype._createTextObject = function() {
      this.textObj = {};
      this._buildMeta();
      this._buildGlyphs();
      this._calculateKerning();
      return this.textObj;
    };

    TextToPath.prototype._buildFabricEles = function() {
      var index, newLine, obj, offset, xAdvance, _i, _j, _len, _len1, _ref, _ref1;
      xAdvance = 0;
      this.fabricGroup = new fabric.Group();
      this.fabricGroup.set('height', this.textObj.meta.ascent).set('top', this.customProperties.top).set('left', this.customProperties.left).scale(this._calcFontScale());
      _ref = this.textObj.glyphs;
      for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
        obj = _ref[index];
        if (!(obj.path === void 0 || obj.path === '')) {
          newLine = new fabric.Path(obj.path);
          if (this.customProperties.strokeWidth !== 0) {
            newLine.set('strokeWidth', this._calcScale(this.customProperties.strokeWidth));
            newLine.set('stroke', this.customProperties.stroke);
          }
          newLine.set('fill', this.customProperties.fill);
          newLine.set('top', 0);
          newLine.set('width', obj.width);
          newLine.set('height', this.textObj.meta.ascent);
          newLine.set('left', xAdvance + (obj.width / 2));
          newLine.set('scaleY', -1);
          this.fabricGroup.add(newLine);
          xAdvance = xAdvance + obj.width;
          this.canvas.renderAll();
        } else {
          xAdvance = xAdvance + obj.width;
          this.canvas.renderAll();
        }
      }
      this.fabricGroup.set('width', xAdvance);
      offset = xAdvance / 2;
      _ref1 = this.fabricGroup.objects;
      for (index = _j = 0, _len1 = _ref1.length; _j < _len1; index = ++_j) {
        obj = _ref1[index];
        obj.set('left', obj.left - offset);
      }
      this.fabricGroup.setAngle(this.customProperties.angle);
      return this.fabricGroup;
    };

    TextToPath.prototype._calcFontScale = function() {
      return this.customProperties.fontSize / this.textObj.meta.unitsPerEm;
    };

    TextToPath.prototype._ascenderToEmSquarePercent = function() {
      return (this.textObj.meta.ascent / this.textObj.meta.unitsPerEm) * 100;
    };

    TextToPath.prototype._calcScale = function(sizeInPixels) {
      return sizeInPixels * this.textObj.meta.unitsPerEm / this.customProperties.fontSize;
    };

    TextToPath.prototype._mergeProperties = function(properties) {
      return this.customProperties = this.$.extend({}, this.defaultProperties, properties);
    };

    TextToPath.prototype.render = function() {
      this.canvas.remove(this.fabricGroup);
      this.canvas.add(this.fabricGroup);
      return this.canvas.renderAll();
    };

    TextToPath.prototype.fill = function(fillcolor) {
      this.customProperties.fill = fillcolor;
      return this._setText();
    };

    TextToPath.prototype.stroke = function(newStroke) {
      this.customProperties.stroke = newStroke;
      return this._setText();
    };

    TextToPath.prototype.strokeWidth = function(newStrokeWidth) {
      this.customProperties.strokeWidth = newStrokeWidth;
      return this._setText();
    };

    TextToPath.prototype.letterSpacing = function(newLetterSpacing) {
      this.customProperties.letterSpacing = newLetterSpacing;
      return this._setText();
    };

    TextToPath.prototype.fontSize = function(newFontSize) {
      this.customProperties.fontSize = newFontSize;
      return this._setText();
    };

    TextToPath.prototype.text = function(newText) {
      this.customProperties.text = newText;
      return this._setText();
    };

    TextToPath.prototype.fontData = function(newFont) {
      this.customProperties.fontData = newFont;
      return this._setText();
    };

    TextToPath.prototype.top = function(newTop) {
      this.customProperties.top = newTop;
      return this._setText();
    };

    TextToPath.prototype.left = function(newLeft) {
      this.customProperties.left = newLeft;
      return this._setText();
    };

    TextToPath.prototype.angle = function(newAngle) {
      this.customProperties.angle = newAngle;
      return this._setText();
    };

    TextToPath.prototype.removeInstance = function() {
      this.canvas.remove(this.fabricGroup);
      return this.canvas.renderAll();
    };

    TextToPath.prototype.getFabObj = function() {
      return this.fabricGroup;
    };

    return TextToPath;

  })();

  if (typeof module !== "undefined" && module !== null) {
    module.exports = TextToPath;
  }

  if (typeof window !== "undefined" && window !== null) {
    window.TextToPath = TextToPath;
  }

}).call(this);
